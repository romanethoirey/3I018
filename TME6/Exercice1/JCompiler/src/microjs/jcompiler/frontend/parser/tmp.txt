
/**********

statements ::=
  statement:st  statements:sts
    {: ((LinkedList<Statement>) sts).addFirst(st); RESULT=sts; :}
| LET:l IDENTIFIER:var EQ expr:e SEMICOL statements:sts  {: LinkedList<Statement> lsts = new LinkedList<Statement>();
                                                              lsts.add(new Let(var, e, sts, lxleft, stsxright));
                                                              RESULT = lsts; :}
  | block_statement:st statements:sts  {: ((LinkedList<Statement>) sts).addFirst(st); RESULT=sts; :}
  | /* empty */  {: RESULT = new LinkedList<Statement>(); :}
  ;
    
statement ::=
  | IDENTIFIER:id EQ expr:e {: RESULT = new Assign(id, e, idxleft, exright); :}
  | VAR:v IDENTIFIER:var EQ expr:e  {: RESULT = new Var(var, e, vxleft, exright); :}
  | expr:e {: RESULT = new VoidExpr(e, exleft, exright); :}
  | RETURN:r expr:e {: RESULT = new Return(e, rxleft, exright); :}
  ;
  
block_statement ::=
  IF:i LPAREN expr:cond RPAREN block:thens ELSE block:elses
             {: RESULT = new If(cond, thens, elses, ixleft, elsesxright); :}
  |Â IF:i LPAREN expr:cond RPAREN block:thens
             {: RESULT = new If(cond, thens, new LinkedList<Statement>(), ixleft, thensxright); :}
  | FUNCTION:f IDENTIFIER:id LPAREN parameters:params RPAREN block:body
             {: RESULT = new Function(id, params, body, fxleft, bodyxright); :}
  ;

block ::=
  LCURLY statements:sts RCURLY {: RESULT = sts; :}
  ; 
  
parameters ::=
  IDENTIFIER:id COMMA parameters:params {: ((LinkedList<String>) params).addFirst(id); RESULT=params; :}
  | IDENTIFIER:id {: LinkedList<String> tempList = new LinkedList<String>();
                     tempList.add(id); RESULT = tempList; :}
  | /* empty */   {: RESULT = new LinkedList<String>(); :}
  ;
  
expr ::=
  INT:n {: RESULT = new IntConst(n, nxleft, nxright); :}
  | BOOL:b {: RESULT = new BoolConst(b, bxleft, bxright); :}
  | expr:fun LPAREN arguments:args RPAREN
          {: RESULT = new Funcall(fun, args, funxleft, argsxright); :}
  | LAMBDA:l LPAREN parameters:params RPAREN block:body
     {: RESULT = new Lambda(params, body, lxleft, bodyxright); :} 
  | IDENTIFIER:var {: RESULT = new EVar(var, varxleft, varxright); :}
  | expr:l PLUS expr:r {: RESULT = new BinOp("+", l, r, lxleft, rxright); :}
  | expr:l MINUS expr:r {: RESULT = new BinOp("-", l, r, lxleft, rxright); :}
  | expr:l TIMES expr:r {: RESULT = new BinOp("*", l, r, lxleft, rxright); :}
  | expr:l DIV expr:r {: RESULT = new BinOp("/", l, r, lxleft, rxright); :}
  | expr:l EQEQ expr:r {: RESULT = new BinOp("==", l, r, lxleft, rxright); :}
  | LPAREN expr:e RPAREN {: RESULT = e; :}
  ;
  
arguments ::=
  expr:e COMMA arguments:args {: ((LinkedList<Expr>) args).addFirst(e); RESULT = args; :}
  | expr:e  {: LinkedList<Expr> tempList = new LinkedList<Expr>();
               tempList.add(e); RESULT = tempList; :}
  | /* empty */  {: RESULT = new LinkedList<Expr>(); :}  
  ;  
**********/
